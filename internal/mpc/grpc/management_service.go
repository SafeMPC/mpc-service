package grpc

import (
	"context"
	"time"

	"github.com/kashguard/go-mpc-infra/internal/infra/storage"
	pb "github.com/kashguard/go-mpc-infra/internal/pb/mpc/v1"
	"github.com/rs/zerolog/log"
)

// SetSigningPolicy 设置签名策略
func (s *GRPCServer) SetSigningPolicy(ctx context.Context, req *pb.SetSigningPolicyRequest) (*pb.SetSigningPolicyResponse, error) {
	log.Info().
		Str("key_id", req.KeyId).
		Str("policy_type", req.PolicyType).
		Int32("min_signatures", req.MinSignatures).
		Msg("Received SetSigningPolicy request")

	if s.metadataStore == nil {
		return &pb.SetSigningPolicyResponse{
			Success: false,
			Message: "metadata store is not initialized",
		}, nil
	}

	policy := &storage.SigningPolicy{
		WalletID:      req.KeyId,
		PolicyType:    req.PolicyType,
		MinSignatures: int(req.MinSignatures),
		CreatedAt:     time.Now(),
		UpdatedAt:     time.Now(),
	}

	if err := s.metadataStore.SaveSigningPolicy(ctx, policy); err != nil {
		log.Error().Err(err).Msg("Failed to save signing policy")
		return &pb.SetSigningPolicyResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	return &pb.SetSigningPolicyResponse{
		Success: true,
		Message: "signing policy set successfully",
	}, nil
}

// GetSigningPolicy 获取签名策略
func (s *GRPCServer) GetSigningPolicy(ctx context.Context, req *pb.GetSigningPolicyRequest) (*pb.GetSigningPolicyResponse, error) {
	if s.metadataStore == nil {
		return nil, nil
	}

	policy, err := s.metadataStore.GetSigningPolicy(ctx, req.KeyId)
	if err != nil {
		log.Error().Err(err).Msg("Failed to get signing policy")
		// If policy not found, return default policy (single signature)
		return &pb.GetSigningPolicyResponse{
			KeyId:         req.KeyId,
			PolicyType:    "single",
			MinSignatures: 1,
		}, nil
	}

	return &pb.GetSigningPolicyResponse{
		KeyId:         policy.WalletID,
		PolicyType:    policy.PolicyType,
		MinSignatures: int32(policy.MinSignatures),
	}, nil
}

// AddUserAuthKey 添加用户鉴权公钥
func (s *GRPCServer) AddUserAuthKey(ctx context.Context, req *pb.AddUserAuthKeyRequest) (*pb.AddUserAuthKeyResponse, error) {
	log.Info().
		Str("key_id", req.KeyId).
		Str("public_key_hex", req.PublicKeyHex).
		Str("member_name", req.MemberName).
		Msg("Received AddUserAuthKey request")

	if s.metadataStore == nil {
		return &pb.AddUserAuthKeyResponse{
			Success: false,
			Message: "metadata store is not initialized",
		}, nil
	}

	authKey := &storage.UserAuthKey{
		WalletID:     req.KeyId,
		PublicKeyHex: req.PublicKeyHex,
		KeyType:      req.KeyType,
		MemberName:   req.MemberName,
		Role:         req.Role,
		CreatedAt:    time.Now(),
	}

	if err := s.metadataStore.SaveUserAuthKey(ctx, authKey); err != nil {
		log.Error().Err(err).Msg("Failed to save user auth key")
		return &pb.AddUserAuthKeyResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	return &pb.AddUserAuthKeyResponse{
		Success:   true,
		Message:   "user auth key added successfully",
		AuthKeyId: "", // ID is generated by DB if needed, but not returned by SaveUserAuthKey currently
	}, nil
}

// RemoveUserAuthKey 删除用户鉴权公钥
func (s *GRPCServer) RemoveUserAuthKey(ctx context.Context, req *pb.RemoveUserAuthKeyRequest) (*pb.RemoveUserAuthKeyResponse, error) {
	log.Info().
		Str("key_id", req.KeyId).
		Str("public_key_hex", req.PublicKeyHex).
		Msg("Received RemoveUserAuthKey request")

	if s.metadataStore == nil {
		return &pb.RemoveUserAuthKeyResponse{
			Success: false,
			Message: "metadata store is not initialized",
		}, nil
	}

	if err := s.metadataStore.DeleteUserAuthKey(ctx, req.KeyId, req.PublicKeyHex); err != nil {
		log.Error().Err(err).Msg("Failed to delete user auth key")
		return &pb.RemoveUserAuthKeyResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	return &pb.RemoveUserAuthKeyResponse{
		Success: true,
		Message: "user auth key removed successfully",
	}, nil
}

// ListUserAuthKeys 列出用户鉴权公钥
func (s *GRPCServer) ListUserAuthKeys(ctx context.Context, req *pb.ListUserAuthKeysRequest) (*pb.ListUserAuthKeysResponse, error) {
	if s.metadataStore == nil {
		return &pb.ListUserAuthKeysResponse{}, nil
	}

	keys, err := s.metadataStore.ListUserAuthKeys(ctx, req.KeyId)
	if err != nil {
		log.Error().Err(err).Msg("Failed to list user auth keys")
		return &pb.ListUserAuthKeysResponse{}, nil
	}

	var pbKeys []*pb.ListUserAuthKeysResponse_UserAuthKey
	for _, key := range keys {
		pbKeys = append(pbKeys, &pb.ListUserAuthKeysResponse_UserAuthKey{
			Id:           key.ID,
			PublicKeyHex: key.PublicKeyHex,
			KeyType:      key.KeyType,
			MemberName:   key.MemberName,
			Role:         key.Role,
			CreatedAt:    key.CreatedAt.Format(time.RFC3339),
		})
	}

	return &pb.ListUserAuthKeysResponse{
		Keys: pbKeys,
	}, nil
}
